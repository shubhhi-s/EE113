# -*- coding: utf-8 -*-
"""EE113_Signals.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1slxOzRIVXrY0TOq_cMV0PQhpfAXTDpBr

# Basic Signals: 
We have seen some signals in the class, mostly of the form $x(t)$, where $t$ is time or space. However, a computer or mobile phone is a digital device, thus it needs to store $x(t)$ as a set of samples at discrete instants of time. It turns out that for a popular class of signals, a certain rate of sampling (or picking points) at uniform intervals of time are good enough. That is we can get back the x(t) from its appropriate samples.  Let us understand some of these concepts by observing a sine wave.

## Plotting a Sine Wave
We will use the matplotlib plotting llibrary, and numpy functions for mathematical manipulation of signals. The following two commands brings the necessary handles for us to use. The names `plt' and 'np' below can be replaced with more convenient names if you desire so.
"""

import matplotlib.pyplot as plt #feel free to change the name 'plt' but no changes otherwise
import numpy as np                 

#Creating two arrays to make a plot
ta = np.arange(0,5.1,0.1)  # a range of values 0, 0.1,0.2, ..., 4.9, 5.0;
ti = np.linspace(0,5,51)    # cut the interval [0,5] into 51, yielding 0, 0.1, ..., 4.9, 5.0;

# Below is  plot with two subplots, plt.subplot(xyz) says plot number z of x rows and y columns 
fig = plt.figure(figsize=(10,5)) #setting total figure size for the two plots below.
plt.subplot(121); plt.plot(ta, ti); plt.title("linear") #the plot below on the left shows a line.
plt.subplot(122); plt.plot(ti, np.sin(2*np.pi*ti)); plt.title("sine wave"); plt.xlabel("time");

"""**Exercise 1**: You have to change the previous code so that only one cycle of the sine wave appears in the time interval (0, 5).

Notice that the sine wave shown is not such a great sight with the peak values appear to be clipped. Take a moment and think what is happening. In reality, the computer only knows certain points in the sine wave (in our case 51 samples),and using this a continuos curve is *drawn* for our eyes. The art of showing the values in between the  samples is known as *interpolation*. Web interfaces like the one we use currently attempts to minimize the computational requirements, so successive points are connected by straightlines and shown. Below we make a smoother plot using 204 points of the same sine wave, but highlight the 51 points  used above in red color. Clearly, if you connect those red dots by lines, you will have the peaks clipped off (see below).
"""

tb = np.linspace(0,5,204)
plt.plot(tb, np.sin(2*np.pi*tb))
plt.plot(ta, np.sin(2*np.pi*ta),'o', color='red', markersize=3);plt.xlabel("time");

"""**Exercise 2: ** Can you plot the above 51 points as  a stem-plot that we saw in the GNURADIO window.

#The Square Wave
 Now that we plotted the sine wave, getting a square wave is very easy. All we need is to plot the *sign of the sine wave*, well that is too many signs, a sin indeed! Here it is :
"""

fig = plt.figure(figsize=(10,5))
plt.subplot(121); plt.plot(tb, np.sign(np.sin(2*np.pi*tb))) ; plt.xlabel("time");# square wave with duty cycle half
plt.subplot(122); plt.plot(tb, np.sign(-0.5 + np.sin(2*np.pi*tb)), color='red'); plt.xlabel("time");#square wave with duty cycle less than half.

"""That was a very easy way to get a square wave from sine wave. But we used a non-linear threshold function to get the sign of the sample value. The question of obtaining a square wave from sinusoid using only linear mechanisms may appear a bit baffling if there is only one sine wave, but this is possible if we allow several sine waves. In fact this question was at the core of many developments in signal processing in the past 200 years or so. How to get a square by linearly superposing sine waves or cosine waves. For a change let us work with cosine waves."""

# Function to compute the approximation
# k amplitude weighted sine waves are added.
# we add frequencies 1,3,5,7 etc with respective weights 2/pi, -2/(3pi), 2/(5pi), -2/(7pi) ..
def SqApprox(k, tval):
  val = np.zeros(tval.size); #array to store results
  for i in range (0,k):          #superposition of k cosine waves.
     val = np.add(val, (2/(np.pi*(2*i+1)))*np.power(-1,i)*np.cos(2*np.pi*(2*i+1)*tval))
  return(val) ; # superposed samples  are returned

fig =  plt.figure(figsize=(10,5)) # set up the canvas.
plt.subplot(121); plt.plot(tb, SqApprox(2, tb)); plt.xlabel("time"); #plot for 2 cosines
plt.subplot(122); plt.plot(tb, SqApprox(10, tb), color='red'); plt.xlabel("time"); #plot 10 cosines

"""Adding just 10 cosine waves takes us very close to a square wave of duty cycle half. The purists may complain about the paint that drips out of this square wave at the corners. While the cross-border incursions do not appear symmetric, that is because we took 204, not so commensurate with the frequency of the square wave form. However, no matter how many points we take, and how large the number of waves we add, the incursions cannot be avoided, a well known principle known as the Gibbs phenomenon. Also how did we choose the coefficients $(-1)^n \frac 2{\pi (2n+1)}, n \geq 0$, and took only *odd* frequencies ($2n+1$) while summing up. All these are mysteries now, but that is the subject of Fourier Series Analysis, a central theme in signal processing.

"""